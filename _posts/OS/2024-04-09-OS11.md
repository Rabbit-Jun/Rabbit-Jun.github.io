---
title: "스레드"
date: 2024-04-09
categories: OS
layout: post
---
# 스레드의 정의
- CPU 스케줄러가 CPU에 전달하는 일 하나
- CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드
    - 운영체제 입장에서의 작업 단위는 프로세스
    - CPU 입장에서의 작업 단위는 스레드
    - **일의 크기는 job(작업) > task(process) > 스레드**
- 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

# 프로세스와 스레드의 차이
- 프로세스끼리는 약하게 연결되어 있는 반면 스레드끼리는 강하게 연결
![differnt](/assets/osimg/differnt.png)
(*task는 서로에게 끼치는 영향이 적고 순서가 바뀌어도 되지만 스레드는 아님*)

# 멀티태스크와 멀티스레드의 차이
![differnt](/assets/osimg/diffent2.png)
(*워드와 스풀러는 따로 작동하다가 출력할 때 데이터를 주고 받는다*)  
(*워드내의 스레드들은 변수나 함수등을 공유하며 워드가 종료되면 다 꺼짐*)

# 스레드 관련 용어
![terms about thred](/assets/osimg/terms.png)
### 멀티스레드
- 프로세스 내 작업을 여러 개의 스레드로 분할하는 프로세스 운영 기법

### 멀티태스킹
- 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하여 작업 부담을 줄이는 기법

### 멀티프로세싱
- 운영체제가 CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경

### CPU 멀티스레드
- 한 번에 하나씩 처리해야 하는 스레드를 작은 단위의 스레드로 분할하여 운영하는 기법

# 멀티스레드의 구조
![multythred](/assets/osimg/multythred.png)

# 멀티스레드의 예
![multythred](/assets/osimg/multyThred2.png)
(*두개의 스레드가 독립적으로 실행되기 때문에 TH_Test와 Test_Main이 섞여서 출력된다.)

# 멀티태스킹 코드의 예
![multytesking](/assets/osimg/multytesking.png)
(*그림 3-32와 같은 결과이지만 fork() 시스템 호출을 사용하여 프로세스 제어 블록, 코드, 데이터 등이 모두 2배가 됨으로써 스레드를 사용할 때보다 낭비가 심하다*)

# 멀티스레드의 장점
![advantage of multythred](/assets/osimg/advantage.png)
1. 응답성 향상
2. 자원 공유
3. 효율성 향상
4. 다중 CPU 지원

# 멀티스레드의 단점
- 모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미침
    -  ex)인터넷 익스플로러에서 여러 개의 화면을 동시에 띄웠는데 그중 하나에 문제가 생기면 인터넷 익스플로러 전체가 종료

# 커널 스레드와 사용자 스레드
- **커널 스레드**: 커널이 직접 생성하고 관리하는 스레드
- **사용자 스레드**: 라이브러리에 의해 구현된 일반적인 스레드

# 사용자 스레드(1 to N 모델)
![user thred](/assets/osimg/user_thred.png)
- 사용자 프로세스 내에 여러 개의 스레드가 커널의 스레드 하나와 연결 (1 to N 모델)
- 라이브러리가 직접 스케줄링을 하고 작업에 필요한 정보를 철이하기 때문에 문맥 교환이 필요 없음
- 커널 스레드가 입출력 작업을 위해 대기 상태에 들어가면 모든 사용자 스레드가 같이 대기하게 됨
- 한 프로세스의 타임 슬라이스를 여러 스레드가 공유하기 때문에 여러 개의 CPU를 동시에 사용할 수 없음

# 커널 스레드 (1 to 1 모델)
![kernerl thred](/assets/osimg/kernel_thred.png)
- 하나의 사용자 스레드가 하나으 커널 스레드와 연결 ( 1 to 1 모댈)
- 독립적으로 스케줄링 되므로 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 계속할 수 있음
- 커널 레벨에서 모든 작업을 지원하기 때문에 멀치 CPU를 사용할 수 있음
- 하나의 스레드가 대기 상태에 있어도 다른 스레드는 작업을 계속할 수 있음
- 커널의 기능을 사용하므로 보안에 강하고 안정적으로 작동
- 문맥 교환할 때 오버헤드 때문에 느리게 작동

# 멀티레벨 스레드(M to N 모델)
![multylevel thred](/assets/osimg/multylevel_thred.png)
- 사용자 스레드와 커널 스레드를 혼합한 방식(M to N 모델)
- 커널 스레드가 대기 상태에 들어가면 다른 커널 스레드가 대신 작업을 하여 사용자 스레드보다 유연하게 작업을 처리할 수 있음
- 커널 스레드를 같이 사용하기 때문에 여전히 문맥 교환 시 오버헤드가 있어 사용자 스레드만큼 빠르지 않음
- 빠르게 움지겨야 하는 스레드는 사용자 스레드로 작동하고, 안정적으로 움직여야 하는 스레드는 커널 스레드로 작동
