---
title: "프로세스의 연산"
date: 2024-04-13
layout: post
categories: OS
---
# 프로세스의 구조
![construction](/assets/osimg/construction.png)

# 코드 영역
- 프로그램의 본문이 기술된 곳
- 프로그래머가 작성한 코드가 탑재되며 탑재된 코드는 읽기 전용으로 처리됨

# 데이터 영역
- 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳
- 데이터는 변하는 값이므로 이곳의 내용은 기본적으로 읽기와 쓰기가 가능

# 스택 영역
- 운영체제가 프로세스를 실행하기 위해 필요한 데이터를 모아놓은 곳
- 프로세스 내에서 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 저장하는 곳
- 운영체제가 사용자 프로세스를 작동하기 위해 유지하는 영역으로 사용자에게는 보이지 않음

# 프로세스의 생성과 실행
- 프로세스는 언제 생성되나? 프로그램을 실행할 때 새로 생성된다
- 사용자가 프로그램을 실행하면? OS가 그 프로그램을 메모리에 가져와 코드 영역에 집어 넣고 PCB를 생성한다. 또한 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.

# 프로세스의 생성 방법
- 프로세스를 새로 생성하는 방법 vs 실행 중인 프로세스를 복사하여 생성하는 방법

# fork() 시스템 호출의 개념
- 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
- 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어짐
![fork](/assets/osimg/fork.png)
- fork() 시스템 호출은 실행 중인 프로세스를 복사하는 함수다. 이때 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로서 둘은 부모-자식 관계가 된다.

# fork() 시스템 호출의 동작 과정
![fork](/assets/osimg/fork2.png)
- fork() 시스템 호출을 하면 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어짐

- 단, 프로세스 제어 블록의 내용 중 다음이 변경됨
    - 프로세스 구분자(PID)
    - 메모리 관련 정보
    - 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)

# fork() 시스템 호출의 장점
- 프로세스의 생성 속도가 빠름
- 추가 작업 없이 자원을 상속할 수 있음
- 시스템 관리를 효율적으로 할 수 있음

# fork() 시스템 호출의 예
- 부모 프로세스의 코드가 실행되어 fork() 문을 만나면 똑같은 내용의 자식 프로세스를 하나 생성
- 이때 fork() 문은 부모 프로세스에 0보다 큰 값을 반환하고 자식 프로세스에 0을 반환
- 만약 0보다 작은 값을 반환하면 자식 프로세스가 생성되지 않은 것으로 여겨 Error를 출력
![fork](/assets/osimg/fork3.png)

# exec() 시스템 호출의 개념
![exec](/assets/osimg/exec.png)
- 기존의 프로세스를 새로운 프로세스로 전환(재사용)하는 함수
- fork():새로운 프로세스를 복사하는 시스템 호출
- exec(): 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출
- exec()시스템 호출은 이미 만들어진 프로세스의 구조를 재활용하는 것이다.

# exec() 시스템 호출의 동작 과정
- exec() 시스템 호출을 하면 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꿔버림
- 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋
- 프로세스 제어 블록의 내용 중 프로세스 구분자, 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항 등은 변하지 않지만 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋
![exec](/assets/osimg/exec2.png)

# exec() 시스템 호출의 예
- exec() 시스템 호출을 사용하여 새로운 프로세스로 전환하더라도 프로세스 제어 블록의 각종 프로세스 구분자(PID, PPID, CPID)가 변경되지 않기 때문에, 프로세스가 종료된 후 부모 프로세스로 돌아올 수 있음
![call to exec](/assets/osimg/call_exec.png)

# 유닉스의 프로세스 계층 구조
- 유닉스의 모든 프로세스는 init프로세스의 자식이 되어 트리 구조를 이룸
![unix process layer structure](/assets/osimg/unix_process.png)

# 프로세스 계층 구조의 장점
1. 여러 작업을 동시에 처리할 수 있다.
![concurrent processing](/assets/osimg/concurrent_processing.png)
2. 프로세스의 재사용이 용이하다.
![recycle](/assets/osimg/recycle.png)
3. 자원 회수가 쉽다
- 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월

# 고아 프로세스와 좀비 프로세스
- **고아 프로세스(orphan process)**는 부모 프로세스가 먼저 종료되어 돌아갈 곳이 없는 **비정상적으로 남아있는** 프로세스
- **좀비 프로세스(zombie process)**는 자식 프로세스가 종료되었는데도 부모 프로세스가 **연락받지 못해** 뒤처리를 하지 않아 발생하는 프로세스
- C 언어에는 exit() 또는 return()문을 사용해 자식 프로세스의 작업이 끝났음을 부모 프로세스에 알림



# 좀비 프로세스와 컴퓨터를 오래 켜면 컴퓨터가 느려지는 현상
- 부팅할 때는 없었던 각종 프로세스가 메모리에 상주하는 데다 좀비 프로세스가 메모리를 차지하기 때문
    - 프로세스가 종료되면 그 프로세스가 사용한 메모리 공간을 깨끗이 청소해야 한다

